function status = fs_rmtouchfiles(subj,varargin);
%function status = fs_rmtouchfiles(subj,[options]);
%
% Usage:
%  status = fs_rmtouchfiles(subj,'key1', value1,...);
%
% Required input:
%  subj is a string specifying the subject name
%
% Optional parameters:
%  'subjdir' - subjects directory (override SUBJECTS_DIR environment variable)
%    subjdir/subj should contain the freesurfer subject directory
%    {default = $SUBJECTS_DIR}
%  'what' - string specifying what action to take
%    'list': list touchfiles
%    'all': delete all touchfiles
%    'vol': delete volume touchfiles only
%    'controlpoints': delete all touchfiles starting at normalization
%    'brainmask': delete all touchfiles starting after skull strip
%    'surf': delete surface  (and brain_finalsurfs) touchfiles only
%    'surfonly': delete surface touchfiles only
%    'final': delete final surfs (and brain_finalsurfs) touchfiles
%    'zero': delete touchfiles with size 0
%    {default: 'list'}
%
% Output:
%  status: returns 1 if ERROR, 0 otherwise
%
% created: 11/18/06 by Don Hagler
% last modified: 03/10/09 by Don Hagler
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

status = 0;
result = [];

full_touchlist = {...
'aparc2aseg.touch'...
'brain_finalsurfs.touch'...
'ca_label.touch'...
'ca_normalize.touch'...
'ca_register.touch'...
'ca_register_inv.touch'...
'conform.touch'...
'convert_input.touch'...
'em_register.touch'...
'fill.touch'...
'inorm1.touch'...
'inorm2.touch'...
'lh.aparc.touch'...
'lh.aparc2.touch'...
'lh.aparcstats.touch'...
'lh.aparcstats2.touch'...
'lh.avgcurv.touch'...
'lh.cortical_ribbon.touch'...
'lh.final_surfaces.touch'...
'lh.inflate1.touch'...
'lh.inflate2.touch'...
'lh.qsphere.touch'...
'lh.smoothwm1.touch'...
'lh.smoothwm2.touch'...
'lh.sphmorph.touch'...
'lh.sphreg.contra.touch'...
'lh.sphreg.touch'...
'lh.tessellate.touch'...
'lh.topofix.touch'...
'mri_remove_neck.touch'...
'nu.touch'...
'rh.aparc.touch'...
'rh.aparc2.touch'...
'rh.aparcstats.touch'...
'rh.aparcstats2.touch'...
'rh.avgcurv.touch'...
'rh.cortical_ribbon.touch'...
'rh.final_surfaces.touch'...
'rh.inflate1.touch'...
'rh.inflate2.touch'...
'rh.qsphere.touch'...
'rh.smoothwm1.touch'...
'rh.smoothwm2.touch'...
'rh.sphmorph.touch'...
'rh.sphreg.contra.touch'...
'rh.sphreg.touch'...
'rh.tessellate.touch'...
'rh.topofix.touch'...
'segstats.touch'...
'skull.lta.touch'...
'skull_strip.touch'...
'talairach.touch'...
'wmsegment.touch'...
'longitudinal_morphsurfs.touch'...
'longitudinal_nonlinreg.touch'...
'longitudinal_nonlinregFlow.touch'...
'longitudinal_nonlinregROI_left_ROIs.touch'...
'longitudinal_nonlinregROI_right_ROIs.touch'...
};

vol_touchlist = {...
'brain_finalsurfs.touch'...
'ca_label.touch'...
'ca_normalize.touch'...
'ca_register.touch'...
'ca_register_inv.touch'...
'conform.touch'...
'em_register.touch'...
'fill.touch'...
'inorm1.touch'...
'inorm2.touch'...
'mri_remove_neck.touch'...
'nu.touch'...
'segstats.touch'...
'skull.lta.touch'...
'skull_strip.touch'...
'talairach.touch'...
'wmsegment.touch'...
'longitudinal_nonlinreg.touch'...
};

brainmask_touchlist = {...
'aparc2aseg.touch'...
'brain_finalsurfs.touch'...
'ca_label.touch'...
'ca_normalize.touch'...
'ca_register.touch'...
'ca_register_inv.touch'...
'em_register.touch'...
'fill.touch'...
'inorm2.touch'...
'lh.aparc.touch'...
'lh.aparc2.touch'...
'lh.aparcstats.touch'...
'lh.aparcstats2.touch'...
'lh.avgcurv.touch'...
'lh.cortical_ribbon.touch'...
'lh.final_surfaces.touch'...
'lh.inflate1.touch'...
'lh.inflate2.touch'...
'lh.qsphere.touch'...
'lh.smoothwm1.touch'...
'lh.smoothwm2.touch'...
'lh.sphmorph.touch'...
'lh.sphreg.contra.touch'...
'lh.sphreg.touch'...
'lh.tessellate.touch'...
'lh.topofix.touch'...
'mri_remove_neck.touch'...
'rh.aparc.touch'...
'rh.aparc2.touch'...
'rh.aparcstats.touch'...
'rh.aparcstats2.touch'...
'rh.avgcurv.touch'...
'rh.cortical_ribbon.touch'...
'rh.final_surfaces.touch'...
'rh.inflate1.touch'...
'rh.inflate2.touch'...
'rh.qsphere.touch'...
'rh.smoothwm1.touch'...
'rh.smoothwm2.touch'...
'rh.sphmorph.touch'...
'rh.sphreg.contra.touch'...
'rh.sphreg.touch'...
'rh.tessellate.touch'...
'rh.topofix.touch'...
'segstats.touch'...
'skull.lta.touch'...
'wmsegment.touch'...
};

controlpoints_touchlist = {...
'aparc2aseg.touch'...
'brain_finalsurfs.touch'...
'ca_label.touch'...
'ca_normalize.touch'...
'ca_register.touch'...
'ca_register_inv.touch'...
'em_register.touch'...
'fill.touch'...
'inorm1.touch'...
'inorm2.touch'...
'lh.aparc.touch'...
'lh.aparc2.touch'...
'lh.aparcstats.touch'...
'lh.aparcstats2.touch'...
'lh.avgcurv.touch'...
'lh.cortical_ribbon.touch'...
'lh.final_surfaces.touch'...
'lh.inflate1.touch'...
'lh.inflate2.touch'...
'lh.qsphere.touch'...
'lh.smoothwm1.touch'...
'lh.smoothwm2.touch'...
'lh.sphmorph.touch'...
'lh.sphreg.contra.touch'...
'lh.sphreg.touch'...
'lh.tessellate.touch'...
'lh.topofix.touch'...
'mri_remove_neck.touch'...
'rh.aparc.touch'...
'rh.aparc2.touch'...
'rh.aparcstats.touch'...
'rh.aparcstats2.touch'...
'rh.avgcurv.touch'...
'rh.cortical_ribbon.touch'...
'rh.final_surfaces.touch'...
'rh.inflate1.touch'...
'rh.inflate2.touch'...
'rh.qsphere.touch'...
'rh.smoothwm1.touch'...
'rh.smoothwm2.touch'...
'rh.sphmorph.touch'...
'rh.sphreg.contra.touch'...
'rh.sphreg.touch'...
'rh.tessellate.touch'...
'rh.topofix.touch'...
'segstats.touch'...
'skull.lta.touch'...
'skull_strip.touch'...
'wmsegment.touch'...
};

surf_touchlist = {...
'aparc2aseg.touch'...
'brain_finalsurfs.touch'...
'fill.touch'...
'lh.aparc.touch'...
'lh.aparc2.touch'...
'lh.aparcstats.touch'...
'lh.aparcstats2.touch'...
'lh.avgcurv.touch'...
'lh.cortical_ribbon.touch'...
'lh.final_surfaces.touch'...
'lh.inflate1.touch'...
'lh.inflate2.touch'...
'lh.qsphere.touch'...
'lh.smoothwm1.touch'...
'lh.smoothwm2.touch'...
'lh.sphmorph.touch'...
'lh.sphreg.contra.touch'...
'lh.sphreg.touch'...
'lh.tessellate.touch'...
'lh.topofix.touch'...
'rh.aparc.touch'...
'rh.aparc2.touch'...
'rh.aparcstats.touch'...
'rh.aparcstats2.touch'...
'rh.avgcurv.touch'...
'rh.cortical_ribbon.touch'...
'rh.final_surfaces.touch'...
'rh.inflate1.touch'...
'rh.inflate2.touch'...
'rh.qsphere.touch'...
'rh.smoothwm1.touch'...
'rh.smoothwm2.touch'...
'rh.sphmorph.touch'...
'rh.sphreg.contra.touch'...
'rh.sphreg.touch'...
'rh.tessellate.touch'...
'rh.topofix.touch'...
'longitudinal_morphsurfs.touch'...
'segstats.touch'...
};

surfonly_touchlist = {...
'aparc2aseg.touch'...
'lh.aparc.touch'...
'lh.aparc2.touch'...
'lh.aparcstats.touch'...
'lh.aparcstats2.touch'...
'lh.avgcurv.touch'...
'lh.cortical_ribbon.touch'...
'lh.final_surfaces.touch'...
'lh.inflate1.touch'...
'lh.inflate2.touch'...
'lh.qsphere.touch'...
'lh.smoothwm1.touch'...
'lh.smoothwm2.touch'...
'lh.sphmorph.touch'...
'lh.sphreg.contra.touch'...
'lh.sphreg.touch'...
'lh.tessellate.touch'...
'lh.topofix.touch'...
'rh.aparc.touch'...
'rh.aparc2.touch'...
'rh.aparcstats.touch'...
'rh.aparcstats2.touch'...
'rh.avgcurv.touch'...
'rh.cortical_ribbon.touch'...
'rh.final_surfaces.touch'...
'rh.inflate1.touch'...
'rh.inflate2.touch'...
'rh.qsphere.touch'...
'rh.smoothwm1.touch'...
'rh.smoothwm2.touch'...
'rh.sphmorph.touch'...
'rh.sphreg.contra.touch'...
'rh.sphreg.touch'...
'rh.tessellate.touch'...
'rh.topofix.touch'...
'longitudinal_morphsurfs.touch'...
'segstats.touch'...
};

finalsurf_touchlist = {...
'aparc2aseg.touch'...
'brain_finalsurfs.touch'...
'lh.aparc.touch'...
'lh.aparc2.touch'...
'lh.aparcstats.touch'...
'lh.aparcstats2.touch'...
'lh.avgcurv.touch'...
'lh.cortical_ribbon.touch'...
'lh.final_surfaces.touch'...
'lh.inflate2.touch'...
'lh.smoothwm2.touch'...
'lh.sphmorph.touch'...
'lh.sphreg.contra.touch'...
'lh.sphreg.touch'...
'rh.aparc.touch'...
'rh.aparc2.touch'...
'rh.aparcstats.touch'...
'rh.aparcstats2.touch'...
'rh.avgcurv.touch'...
'rh.cortical_ribbon.touch'...
'rh.final_surfaces.touch'...
'rh.inflate2.touch'...
'rh.smoothwm2.touch'...
'rh.sphmorph.touch'...
'rh.sphreg.contra.touch'...
'rh.sphreg.touch'...
'segstats.touch'...
};

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% parse options

try
  options = varargin;
  for index = 1:length(options)
      if iscell(options{index}) & ~iscell(options{index}{1}), options{index} = { options{index} }; end;
  end;
  if ~isempty( varargin ), g=struct(options{:}); 
  else g = []; end;
catch
  error(sprintf('%s: calling convention {''key'', value, ... } error\n',mfilename));
end;

if ~isfield(g,'subjdir'), g.subjdir = []; end;
if ~isfield(g,'what'), g.what = 'list'; end;

gfields = fieldnames(g);
for index=1:length(gfields)
   switch gfields{index}
   case {'subjdir' 'what'},;
   otherwise, error([mfilename ': unrecognized option: ''' gfields{index} '''' ]);
   end;
end;

% get rid of options struct
subjdir = g.subjdir;
what = g.what;
clear g;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% check parameters
if nargin<1, help(mfilename); return; end;  

if ~exist('subjdir','var'), subjdir = []; end;
if isempty(subjdir)
  subjdir = getenv('SUBJECTS_DIR');
  if isempty(subjdir)
    error('SUBJECTS_DIR not defined as an environment variable');
  end;
end;

touchdir = sprintf('%s/%s/touch',subjdir,subj);
if ~exist(touchdir,'dir')
  error(sprintf('touch dir %s not found\n',touchdir));
end

allowed_actions = {'list','all','vol','controlpoints','surf','surfonly','final','zero','brainmask'};
if ~ismember(what,allowed_actions)
  fprintf('%s: ''what'' must be one of these:\n',mfilename);
  disp(allowed_actions);
  error('disallowed action');
end;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

switch what
  case 'list' % list files only
    flist = dir([touchdir '/*.touch']);
    fprintf('%s: contents of touchdir %s:\n',mfilename,touchdir);
    for f=1:length(flist)
      fprintf('%s\n',flist(f).name);
    end;
  case 'all' % delete all touch files
    flist = full_touchlist;
    for f=1:length(flist)
      fname = [touchdir '/' flist{f}]; 
      if exist(fname,'file')
        [status,result] = unix(sprintf('rm %s',fname));
        if status, disp(result); return; end;
      end;
    end;
  case 'vol' % delete vol touch files
    flist = vol_touchlist;
    for f=1:length(flist)
      fname = [touchdir '/' flist{f}]; 
      if exist(fname,'file')
        [status,result] = unix(sprintf('rm %s',fname));
        if status, disp(result); return; end;
      end;
    end;
  case 'controlpoints' % delete control points touch files
    flist = controlpoints_touchlist;
    for f=1:length(flist)
      fname = [touchdir '/' flist{f}]; 
      if exist(fname,'file')
        [status,result] = unix(sprintf('rm %s',fname));
        if status, disp(result); return; end;
      end;
    end;
  case 'surf' % delete surf touch files
    flist = surf_touchlist;
    for f=1:length(flist)
      fname = [touchdir '/' flist{f}]; 
      if exist(fname,'file')
        [status,result] = unix(sprintf('rm %s',fname));
        if status, disp(result); return; end;
      end;
    end;
  case 'surfonly' % delete surf touch files
    flist = surfonly_touchlist;
    for f=1:length(flist)
      fname = [touchdir '/' flist{f}]; 
      if exist(fname,'file')
        [status,result] = unix(sprintf('rm %s',fname));
        if status, disp(result); return; end;
      end;
    end;
  case 'final' % delete final surf touch files
    flist = finalsurf_touchlist;
    for f=1:length(flist)
      fname = [touchdir '/' flist{f}]; 
      if exist(fname,'file')
        [status,result] = unix(sprintf('rm %s',fname));
        if status, disp(result); return; end;
      end;
    end;
  case 'zero' % delete touch files with 0 file size
    flist = dir([touchdir '/*.touch']);
    for f=1:length(flist)
      fname = [touchdir '/' flist(f).name]; 
      tmp_flist = dir(fname);
      if isempty(tmp_flist), continue; end;
      if tmp_flist(1).bytes == 0
        [status,result] = unix(sprintf('rm %s',fname));
        if status, disp(result); return; end;
      end;
    end;
  case 'brainmask' % delete all touchfiles starting after skull strip
    flist = brainmask_touchlist;
    for f=1:length(flist)
      fname = [touchdir '/' flist{f}]; 
      if exist(fname,'file')
        [status,result] = unix(sprintf('rm %s',fname));
        if status, disp(result); return; end;
      end;
    end;  
end;

